<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Gemini Auto-Split Recorder ver.1.0.1 (2026-02-15 23:56)</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23007bff' width='100' height='100' rx='20'/><text x='50%' y='50%' font-size='60' fill='white' text-anchor='middle' dominant-baseline='central'>ğŸ™ï¸</text></svg>">
    <meta name="theme-color" content="#007bff">
    <style>
        :root {
            --primary-color: #3b82f6;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --bg-color: #f0f4f8;
            --card-bg: #ffffff;
            --card-border: #e2e8f0;
            --text-color: #1e293b;
            --text-muted: #64748b;
            --input-bg: #f8fafc;
            --input-border: #cbd5e1;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 12px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 800px;
            background: var(--card-bg);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid var(--card-border);
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
        @media (max-width: 640px) {
            body {
                padding: 8px;
            }

            .container {
                padding: 16px;
                border-radius: 12px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 20px;
            }

            h3 {
                font-size: 1rem;
            }
        }

        h1 {
            margin-top: 0;
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--text-color);
        }

        h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-color);
        }

        /* Input Section */
        .input-group {
            margin-bottom: 20px;
        }

        @media (max-width: 640px) {
            .input-group {
                margin-bottom: 16px;
            }

            label {
                font-size: 0.8125rem;
            }

            input[type="password"], input[type="text"], input[type="number"], select {
                padding: 12px;
                font-size: 16px; /* iOSã§ã‚ºãƒ¼ãƒ ã‚’é˜²ã */
            }
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--text-color);
        }

        input[type="password"], input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--input-border);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 0.9375rem;
            background: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.2s;
        }

        input[type="password"]:focus, input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        small {
            color: var(--text-muted);
            font-size: 0.8125rem;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .mode-option {
            min-width: 0;
        }

        @media (max-width: 640px) {
            .mode-selector {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .mode-option label {
                padding: 14px 10px;
                font-size: 0.875rem;
            }
        }

        .mode-option input[type="radio"] {
            display: none;
        }

        .mode-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 16px 12px;
            border: 2px solid var(--card-border);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            color: var(--text-muted);
            position: relative;
        }

        .mode-option input[type="radio"]:checked + label {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            color: var(--text-color);
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }

        .mode-option input[type="radio"]:checked + label::after {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--primary-color);
        }

        .mode-option label:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            color: var(--text-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .mode-option label small {
            font-size: 0.625rem;
            line-height: 1;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            color: white;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex: 1;
        }

        @media (max-width: 640px) {
            .controls {
                flex-direction: column;
                gap: 10px;
            }

            button {
                width: 100%;
                padding: 14px 20px;
                font-size: 0.9375rem;
            }
        }

        .btn-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        #btnStart { 
            background-color: var(--primary-color); 
        }
        #btnStart:hover:not(:disabled) { 
            background-color: #0066cc; 
        }
        #btnStart:disabled { 
            background-color: var(--input-bg); 
            color: var(--text-muted);
            cursor: not-allowed; 
        }
        
        #btnStop { 
            background-color: var(--danger-color); 
        }
        #btnStop:hover:not(:disabled) { 
            background-color: #dc2626; 
        }
        #btnStop:disabled { 
            background-color: var(--input-bg); 
            color: var(--text-muted);
            cursor: not-allowed; 
        }

        /* Status & Timer */
        .status-panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            position: relative;
            overflow: hidden;
        }

        @media (max-width: 640px) {
            .status-panel {
                padding: 14px;
            }

            .status-panel > div:first-child {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .timer-section {
                width: 100%;
                text-align: left;
                margin-top: 12px;
            }
        }

        .status-panel.recording::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(59, 130, 246, 0.15) 50%, transparent 100%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .status-panel > div:first-child {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .recording-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            color: var(--primary-color);
            font-size: 20px;
            transition: all 0.2s;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }

        @media (max-width: 640px) {
            .recording-indicator {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }
        }

        .recording-indicator.active {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            color: var(--danger-color);
            animation: pulse-dot 1.2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            box-shadow: 0 2px 12px rgba(239, 68, 68, 0.3);
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .status-info {
            flex: 1;
        }

        .status-info p:first-child {
            font-size: 0.875rem;
            font-weight: 600;
            margin: 0 0 4px 0;
            color: var(--text-color);
        }

        .status-info p:last-child {
            font-size: 0.75rem;
            margin: 0;
            color: var(--text-muted);
        }

        .status-info .model-name {
            font-family: monospace;
            color: var(--primary-color);
            font-weight: 500;
        }

        .timer-section {
            text-align: right;
        }

        .timer {
            font-family: monospace;
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--text-color);
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        @media (max-width: 640px) {
            .timer {
                font-size: 1.5rem;
            }
        }

        .timer-section > div:last-child {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Log Output */
        #logs {
            margin-top: 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .log-entry {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .log-entry:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }

        .log-header {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-header strong {
            color: var(--text-color);
            font-weight: 600;
        }

        .log-content {
            white-space: pre-wrap;
            line-height: 1.7;
            color: var(--text-color);
            font-size: 0.9375rem;
        }

        .log-actions {
            display: flex;
            gap: 6px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        @media (max-width: 640px) {
            .log-actions {
                flex-direction: column;
                gap: 8px;
            }

            .log-action-btn {
                width: 100%;
                padding: 10px;
            }

            .log-entry {
                padding: 14px;
            }

            .log-content {
                font-size: 0.875rem;
            }
        }

        .log-action-btn {
            padding: 6px 12px;
            font-size: 0.8125rem;
            border: 1px solid var(--card-border);
            border-radius: 6px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-color);
        }

        .log-action-btn:hover {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-color: var(--primary-color);
            color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }

        .log-action-btn.copy {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .log-action-btn.save {
            border-color: var(--success-color);
            color: var(--success-color);
        }

        .log-action-btn.share {
            border-color: var(--text-muted);
            color: var(--text-muted);
        }

        .log-action-btn.retry {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .log-retry-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .log-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Settings Toggle */
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .settings-toggle:hover {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-color: var(--primary-color);
        }

        .settings-toggle-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .settings-toggle.active .settings-icon {
            transform: rotate(90deg);
        }

        .settings-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            margin-bottom: 0;
        }

        .settings-panel.open {
            max-height: 500px;
            margin-bottom: 20px;
        }

        .loading {
            color: var(--primary-color);
            font-style: italic;
            opacity: 0.8;
        }
        
        .error {
            color: var(--danger-color);
            background: rgba(239, 68, 68, 0.1);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Progress Bar for Segment */
        .progress-container {
            width: 100%;
            background-color: var(--input-bg);
            height: 6px;
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.5s ease-linear;
            border-radius: 3px;
        }

        .progress-bar.warning {
            background-color: var(--warning-color);
        }

        .progress-bar.danger {
            background-color: var(--danger-color);
        }

        /* Rate Limit Display */
        .rate-limit-panel {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.875rem;
        }

        .rate-limit-panel.warning {
            border-color: #fbbf24;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        }

        .rate-limit-panel.danger {
            border-color: #f87171;
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
        }

        .rate-limit-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 10px;
        }

        .rate-limit-header span {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-muted);
        }

        .rate-limit-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        @media (max-width: 640px) {
            .rate-limit-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .rate-limit-panel {
                padding: 10px;
            }
        }

        .rate-limit-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .rate-limit-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rate-limit-label {
            font-size: 0.625rem;
            color: var(--text-muted);
        }

        .rate-limit-count {
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--text-color);
        }

        .rate-limit-progress {
            height: 4px;
            background-color: var(--input-bg);
            border-radius: 2px;
            overflow: hidden;
        }

        .rate-limit-progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s, background-color 0.3s;
            border-radius: 2px;
        }

        .rate-limit-progress-bar.warning {
            background-color: var(--warning-color);
        }

        .rate-limit-progress-bar.danger {
            background-color: var(--danger-color);
        }

        .countdown {
            font-family: monospace;
            color: var(--danger-color);
            font-weight: 600;
            font-size: 0.75rem;
        }

        .log-header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            gap: 12px;
        }

        .export-all-btn {
            padding: 8px 16px;
            font-size: 0.875rem;
            background: var(--success-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .export-all-btn:hover {
            background: #16a34a;
        }

        .file-load-btn {
            padding: 8px 16px;
            font-size: 0.875rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .file-load-btn:hover {
            background: #2563eb;
        }

        .app-update-btn {
            padding: 8px 16px;
            font-size: 0.875rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .app-update-btn:hover {
            background: #2563eb;
        }

        .app-update-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 24px;
        }

        .header-row h1 {
            margin: 0;
        }

        @media (max-width: 640px) {
            .header-row {
                flex-direction: column;
                align-items: stretch;
            }

            .app-update-btn {
                width: 100%;
            }

            .log-header-section {
                flex-direction: column;
                align-items: stretch;
            }

            .file-load-btn,
            .export-all-btn {
                width: 100%;
                padding: 10px;
            }

            h3 {
                margin-bottom: 8px;
            }
        }

        /* APIåˆ¶é™è¨­å®šã®ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
        @media (max-width: 640px) {
            .input-group > div[style*="grid"] {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
        }

        /* ===== éŒ²éŸ³ç”»é¢ï¼ˆãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ï¼‰Zelloé¢¨ ===== */
        body { padding: 0; margin: 0; display: block; }
        .app-wrapper { min-height: 100vh; position: relative; width: 100%; }
        
        .view { display: none; min-height: 100vh; }
        .view.active { display: flex; flex-direction: column; }
        
        #main-view {
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: background-color 0.3s;
        }
        #main-view.idle { background: #eff6ff; }
        #main-view.recording { background: rgba(254, 226, 226, 0.9); }
        
        .settings-fab {
            position: fixed;
            top: max(16px, env(safe-area-inset-top));
            right: max(16px, env(safe-area-inset-right));
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: 2px solid #93c5fd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            transition: all 0.2s;
        }
        .settings-fab:hover { background: #fff; border-color: #3b82f6; transform: scale(1.05); }
        
        .mic-button-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 24px;
            box-sizing: border-box;
        }
        .mic-button {
            width: min(100vw, 100vh);
            max-width: min(100vw, 100vh);
            aspect-ratio: 1;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 4px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            -webkit-tap-highlight-color: transparent;
        }
        .mic-button.idle {
            background: linear-gradient(135deg, #bfdbfe 0%, #93c5fd 100%);
            box-shadow: 0 4px 24px rgba(59, 130, 246, 0.25);
        }
        .mic-button.recording {
            background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%);
            border-color: #dc2626;
            box-shadow: 0 0 40px rgba(220, 38, 38, 0.35);
        }
        .mic-button .mic-icon {
            font-size: min(25vw, 25vh);
            line-height: 1;
            user-select: none;
        }
        .mic-button.idle .mic-icon { filter: none; }
        .mic-button.recording .mic-icon { filter: brightness(0.9); }
        
        .timer-badge {
            position: fixed;
            bottom: max(24px, env(safe-area-inset-bottom));
            right: max(24px, env(safe-area-inset-right));
            font-family: monospace;
            font-size: 1.25rem;
            font-weight: 700;
            color: #991b1b;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
            z-index: 50;
        }
        .timer-badge.hidden { display: none !important; }
        
        /* è¨­å®šç”»é¢ */
        #settings-view {
            background: var(--bg-color);
            padding: 12px;
            padding-bottom: 24px;
            flex-direction: column;
            align-items: center;
        }
        #settings-view .container { flex: 1; width: 100%; max-width: 800px; }
        .back-to-main {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9375rem;
            color: var(--primary-color);
            font-weight: 500;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }
        .back-to-main:hover { background: #f0f9ff; }

    </style>
</head>
<body>

<div class="app-wrapper">
    <!-- éŒ²éŸ³ç”»é¢ï¼ˆãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ï¼‰ -->
    <div id="main-view" class="view active idle">
        <button type="button" class="settings-fab" id="btnOpenSettings" aria-label="è¨­å®š">âš™ï¸</button>
        <div class="mic-button-wrapper">
            <button type="button" id="btnMic" class="mic-button idle" aria-label="éŒ²éŸ³">
                <span class="mic-icon">ğŸ™ï¸</span>
            </button>
        </div>
        <div id="timerBadge" class="timer-badge hidden">
            <span id="timerDisplay">00:00</span>
            <span> #</span><span id="segmentCounterDisplay">1</span>
        </div>
    </div>

    <!-- è¨­å®šç”»é¢ -->
        <div id="settings-view" class="view">
        <button type="button" class="back-to-main" id="btnBackToMain">â† éŒ²éŸ³ç”»é¢ã«æˆ»ã‚‹</button>
        <div class="container">
    <div class="header-row">
        <h1>ğŸ™ï¸ Gemini Auto-Split Recorder</h1>
        <button type="button" id="btnAppUpdate" class="app-update-btn" title="ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤ã—ã¦æœ€æ–°ç‰ˆã‚’å–å¾—">ğŸ”„ ã‚¢ãƒ—ãƒªæ›´æ–°</button>
    </div>
    <!-- ä»¥ä¸‹ã¯è¨­å®šç”»é¢ç”¨ã€‚éŒ²éŸ³åˆ¶å¾¡ã¯ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ã®ãƒã‚¤ã‚¯ãƒœã‚¿ãƒ³ã§è¡Œã† -->
    
    <div class="input-group">
        <div class="settings-toggle" id="apiKeyToggle">
            <div class="settings-toggle-content">
                <span class="settings-icon">âš™ï¸</span>
                <label style="margin: 0; cursor: pointer; font-weight: 500;">APIã‚­ãƒ¼ç®¡ç†</label>
            </div>
            <span style="font-size: 0.875rem; color: var(--text-muted); transition: transform 0.3s;">â–¼</span>
        </div>
        <div class="settings-panel" id="apiKeyPanel">
            <label for="apiKeySelect">APIã‚­ãƒ¼é¸æŠ</label>
            <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-bottom: 8px;">
                <select id="apiKeySelect" style="width: 100%; padding: 10px; border-radius: 6px; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text-color);">
                    <option value="">æ–°ã—ã„APIã‚­ãƒ¼ã‚’è¿½åŠ ...</option>
                </select>
                <button id="btnAddApiKey" style="padding: 10px 16px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; white-space: nowrap;">â• è¿½åŠ </button>
            </div>
            <input type="password" id="apiKey" placeholder="AIzaSy..." value="" style="margin-bottom: 8px;">
            <input type="text" id="apiKeyName" placeholder="APIã‚­ãƒ¼åï¼ˆä¾‹ï¼šç„¡æ–™æ ã€æœ‰æ–™APIï¼‰" value="" style="margin-bottom: 8px;">
            <div style="display: flex; gap: 8px;">
                <button id="btnSaveApiKey" style="flex: 1; padding: 10px; background: var(--success-color); color: white; border: none; border-radius: 6px; cursor: pointer;">ğŸ’¾ ä¿å­˜</button>
                <button id="btnDeleteApiKey" style="flex: 1; padding: 10px; background: var(--danger-color); color: white; border: none; border-radius: 6px; cursor: pointer;">ğŸ—‘ï¸ å‰Šé™¤</button>
            </div>
            <small>â€»ã‚­ãƒ¼ã¯ãƒ–ãƒ©ã‚¦ã‚¶å†…ã«ã®ã¿ä¿å­˜ã•ã‚Œã€å¤–éƒ¨ã«ã¯é€ä¿¡ã•ã‚Œã¾ã›ã‚“ã€‚</small>
        </div>
    </div>

    <div class="input-group">
        <label for="modelSelect">ä½¿ç”¨ãƒ¢ãƒ‡ãƒ«</label>
        <select id="modelSelect" style="width: 100%; padding: 10px; border-radius: 6px; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text-color);">
            <option value="gemini-2.5-flash">Gemini 2.5 Flashï¼ˆç„¡æ–™æ æ¨å¥¨ï¼‰</option>
            <option value="gemini-2.5-pro">Gemini 2.5 Proï¼ˆæœ‰æ–™ãƒ»é«˜ç²¾åº¦ï¼‰</option>
            <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash Liteï¼ˆè»½é‡ï¼‰</option>
        </select>
        <small>â€»ç§˜åŒ¿æ€§ã®é«˜ã„ä¼šè­°ãƒ¢ãƒ¼ãƒ‰ã§ã¯è‡ªå‹•çš„ã«Gemini 2.5 ProãŒé¸æŠã•ã‚Œã¾ã™</small>
    </div>

    <div class="input-group">
        <label>éŒ²éŸ³ãƒ¢ãƒ¼ãƒ‰</label>
        <div class="mode-selector">
            <div class="mode-option">
                <input type="radio" id="mode-meeting" name="recordingMode" value="meeting" checked>
                <label for="mode-meeting">ğŸ“‹ ä¼šè­°éŒ²ãƒ¢ãƒ¼ãƒ‰<br><small>å¤šäººæ•°å¯¾å¿œ</small></label>
            </div>
            <div class="mode-option">
                <input type="radio" id="mode-medical" name="recordingMode" value="medical">
                <label for="mode-medical">ğŸ¥ ç—…çŠ¶èª¬æ˜ãƒ¢ãƒ¼ãƒ‰<br><small>è¨ºå¯Ÿè¨˜éŒ²</small></label>
            </div>
            <div class="mode-option">
                <input type="radio" id="mode-patient" name="recordingMode" value="patient">
                <label for="mode-patient">ğŸ“ å‚·ç—…è€…æƒ…å ±ãƒ¢ãƒ¼ãƒ‰<br><small>æ‚£è€…æƒ…å ±</small></label>
            </div>
            <div class="mode-option">
                <input type="radio" id="mode-secure" name="recordingMode" value="secure">
                <label for="mode-secure">ğŸ”’ ç§˜åŒ¿æ€§ã®é«˜ã„ä¼šè­°<br><small>æœ‰æ–™APIæ¨å¥¨</small></label>
            </div>
        </div>
    </div>

    <div class="input-group">
        <div class="settings-toggle" id="settingsToggle">
            <div class="settings-toggle-content">
                <span class="settings-icon">âš™ï¸</span>
                <label style="margin: 0; cursor: pointer; font-weight: 500;">APIåˆ¶é™è¨­å®š</label>
            </div>
            <span style="font-size: 0.875rem; color: var(--text-muted); transition: transform 0.3s;">â–¼</span>
        </div>
        <div class="settings-panel" id="settingsPanel">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 12px; background: var(--input-bg); border-radius: 8px; border: 1px solid var(--card-border);">
                <div>
                    <label for="rpmLimit" style="font-size: 0.9rem;">RPMï¼ˆåˆ†ã‚ãŸã‚Šï¼‰:</label>
                    <input type="number" id="rpmLimit" value="5" min="1" style="width: 100%;">
                </div>
                <div>
                    <label for="rpdLimit" style="font-size: 0.9rem;">RPDï¼ˆæ—¥ã‚ãŸã‚Šï¼‰:</label>
                    <input type="number" id="rpdLimit" value="20" min="1" style="width: 100%;">
                </div>
            </div>
            <small style="display: block; margin-top: 8px;">â€»é¸æŠä¸­ã®APIã‚­ãƒ¼ã”ã¨ã«è¨­å®šãŒä¿å­˜ã•ã‚Œã¾ã™ã€‚AI Studioã®ä½¿ç”¨çŠ¶æ³ãƒšãƒ¼ã‚¸ã§ç¢ºèªã—ãŸåˆ¶é™å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</small>
        </div>
    </div>

    <div class="rate-limit-panel" id="rateLimitPanel" style="display: none;">
        <div class="rate-limit-header">
            <span>âš ï¸</span>
            <span>APIä½¿ç”¨çŠ¶æ³</span>
        </div>
        <div class="rate-limit-grid">
            <div class="rate-limit-item">
                <div class="rate-limit-item-header">
                    <span class="rate-limit-label">RPM</span>
                    <span class="rate-limit-count" id="rpmCount">0/5</span>
                </div>
                <div class="rate-limit-progress">
                    <div class="rate-limit-progress-bar" id="rpmProgressBar"></div>
                </div>
            </div>
            <div class="rate-limit-item">
                <div class="rate-limit-item-header">
                    <span class="rate-limit-label">RPD</span>
                    <span class="rate-limit-count" id="rpdCount">0/20</span>
                </div>
                <div class="rate-limit-progress">
                    <div class="rate-limit-progress-bar" id="rpdProgressBar"></div>
                </div>
            </div>
        </div>
        <div class="rate-limit-item" id="rpmCountdown" style="display: none; margin-top: 8px;">
            <span class="rate-limit-label">RPMãƒªã‚»ãƒƒãƒˆã¾ã§: <span class="countdown" id="rpmCountdownTime">--:--</span></span>
        </div>
        <div class="rate-limit-item" id="rpdCountdown" style="display: none; margin-top: 4px;">
            <span class="rate-limit-label">RPDãƒªã‚»ãƒƒãƒˆã¾ã§: <span class="countdown" id="rpdCountdownTime">--:--</span></span>
        </div>
    </div>

    <!-- ãƒ¢ãƒ‡ãƒ«è¡¨ç¤ºç”¨ï¼ˆè¨­å®šç”»é¢å†…ï¼‰ -->
    <div style="margin-bottom: 16px; font-size: 0.875rem; color: var(--text-muted);">
        ä½¿ç”¨ãƒ¢ãƒ‡ãƒ«: <span class="model-name" id="modelDisplay">gemini-2.5-flash</span>
    </div>

    <div class="log-header-section">
        <h3 style="margin: 0;">ğŸ“ è¦ç´„ãƒ­ã‚°</h3>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <input type="file" id="audioFileInput" accept="audio/*" style="display: none;">
            <button type="button" id="btnLoadFile" class="file-load-btn">ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿</button>
            <button id="btnExportAll" class="export-all-btn">ğŸ“¥ å…¨ãƒ­ã‚°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
        </div>
    </div>
    <div id="logs"></div>
        </div>
    </div>
</div>

<script>
/**
 * Application Core Logic
 * Handles MediaRecorder, Timer Management, and Gemini API Interaction.
 */
class RecorderApp {
    constructor() {
        // Configuration
        this.MODEL_NAME = "gemini-2.5-flash"; // ç„¡æ–™æ ã§åˆ©ç”¨å¯èƒ½ 
        this.SEGMENT_LIMIT_MS = 15 * 60 * 1000; // 15 minutes (Safe margin for 20MB limit)
        // this.SEGMENT_LIMIT_MS = 1 * 60 * 1000; // Debug: 1 minute

        // Rate Limiting
        this.RPM_LIMIT = 5; // Requests Per Minute (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)
        this.RPD_LIMIT = 20; // Requests Per Day (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤)
        this.rpmCount = 0; // ç¾åœ¨ã®åˆ†ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°
        this.rpdCount = 0; // ç¾åœ¨ã®æ—¥ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°
        this.rpmResetTime = null; // RPMãƒªã‚»ãƒƒãƒˆæ™‚åˆ»
        this.rpdResetTime = null; // RPDãƒªã‚»ãƒƒãƒˆæ™‚åˆ»
        this.rateLimitInterval = null; // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³æ›´æ–°ç”¨

        // State
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.recordingMimeType = 'audio/webm'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆiOSã§ã¯setupRecorderã§audio/mp4ã«ä¸Šæ›¸ãï¼‰
        this.isRecording = false;
        this.startTime = null;
        this.timerInterval = null;
        this.segmentCounter = 1;
        this.wakeLock = null; // â˜… Wake Lockç”¨ã®å¤‰æ•°ã‚’è¿½åŠ 

        // IndexedDB for audio backup (APIå¤±æ•—æ™‚ã®å†é€ä¿¡ç”¨)
        this.AUDIO_DB_NAME = 'VoiceREC_audio';
        this.AUDIO_STORE_NAME = 'audioSegments';

        // DOM Elements
        this.apiKeyInput = document.getElementById('apiKey');
        this.apiKeyNameInput = document.getElementById('apiKeyName');
        this.apiKeySelect = document.getElementById('apiKeySelect');
        this.btnAddApiKey = document.getElementById('btnAddApiKey');
        this.btnSaveApiKey = document.getElementById('btnSaveApiKey');
        this.btnDeleteApiKey = document.getElementById('btnDeleteApiKey');
        this.modelSelect = document.getElementById('modelSelect');
        this.btnMic = document.getElementById('btnMic');
        this.mainView = document.getElementById('main-view');
        this.micButton = document.getElementById('btnMic');
        this.timerBadge = document.getElementById('timerBadge');
        this.timerDisplay = document.getElementById('timerDisplay');
        this.segmentCounterDisplay = document.getElementById('segmentCounterDisplay');
        this.progressBar = document.getElementById('segmentProgress');
        this.btnOpenSettings = document.getElementById('btnOpenSettings');
        this.btnBackToMain = document.getElementById('btnBackToMain');
        this.logsContainer = document.getElementById('logs');
        this.modeInputs = document.querySelectorAll('input[name="recordingMode"]');
        this.modelDisplay = document.getElementById('modelDisplay');
        this.rpmLimitInput = document.getElementById('rpmLimit');
        this.rpdLimitInput = document.getElementById('rpdLimit');
        this.rateLimitPanel = document.getElementById('rateLimitPanel');
        this.settingsToggle = document.getElementById('settingsToggle');
        this.settingsPanel = document.getElementById('settingsPanel');
        this.rpmCountDisplay = document.getElementById('rpmCount');
        this.rpdCountDisplay = document.getElementById('rpdCount');
        this.rpmCountdownDisplay = document.getElementById('rpmCountdown');
        this.rpdCountdownDisplay = document.getElementById('rpdCountdown');
        this.rpmCountdownTime = document.getElementById('rpmCountdownTime');
        this.rpdCountdownTime = document.getElementById('rpdCountdownTime');
        this.btnExportAll = document.getElementById('btnExportAll');
        this.audioFileInput = document.getElementById('audioFileInput');
        this.btnLoadFile = document.getElementById('btnLoadFile');
        this.statusPanel = null;
        this.rpmProgressBar = document.getElementById('rpmProgressBar');
        this.rpdProgressBar = document.getElementById('rpdProgressBar');

        // API Key Management
        this.apiKeys = this.loadApiKeys();
        this.currentApiKeyId = null;

        // Bind Eventsï¼ˆãƒã‚¤ã‚¯ãƒœã‚¿ãƒ³: ã‚¿ãƒƒãƒ—ã§éŒ²éŸ³é–‹å§‹/åœæ­¢ã‚’åˆ‡ã‚Šæ›¿ãˆï¼‰
        if (this.btnMic) {
            this.btnMic.addEventListener('click', () => {
                if (this.isRecording) this.stopRecording(true);
                else this.startRecording();
            });
        }
        
        // API Key Management Events
        if (this.btnAddApiKey) this.btnAddApiKey.addEventListener('click', () => this.addNewApiKey());
        if (this.btnSaveApiKey) this.btnSaveApiKey.addEventListener('click', () => this.saveApiKey());
        if (this.btnDeleteApiKey) this.btnDeleteApiKey.addEventListener('click', () => this.deleteApiKey());
        if (this.apiKeySelect) this.apiKeySelect.addEventListener('change', (e) => this.selectApiKey(e.target.value));
        if (this.modelSelect) this.modelSelect.addEventListener('change', (e) => this.updateModel(e.target.value));
        
        // Initialize API Key Management
        this.initApiKeyManagement();

        // Initialize IndexedDB for audio backup
        this.initAudioDB();

        // Load API Key from localStorage (backward compatibility)
        const savedKey = localStorage.getItem('gemini_api_key');
        if (savedKey && this.apiKeys.length === 0) {
            // æ—¢å­˜ã®APIã‚­ãƒ¼ã‚’ç§»è¡Œ
            this.addApiKey('æ—¢å­˜ã®APIã‚­ãƒ¼', savedKey);
        }
        
        // Load Mode from localStorage
        const savedMode = localStorage.getItem('recording_mode') || 'meeting';
        const modeInput = document.querySelector(`input[name="recordingMode"][value="${savedMode}"]`);
        if (modeInput) modeInput.checked = true;
        
        this.modeInputs.forEach(input => {
            input.addEventListener('change', (e) => {
                localStorage.setItem('recording_mode', e.target.value);
                this.handleModeChange();
            });
        });
        
        // Initial mode change handling
        this.handleModeChange();

        // Load Rate Limit Settings
        const savedRpm = localStorage.getItem('rpm_limit');
        const savedRpd = localStorage.getItem('rpd_limit');
        if (savedRpm) {
            this.rpmLimitInput.value = savedRpm;
            this.RPM_LIMIT = parseInt(savedRpm);
        }
        if (savedRpd) {
            this.rpdLimitInput.value = savedRpd;
            this.RPD_LIMIT = parseInt(savedRpd);
        }

        // Load Rate Limit Counts
        this.loadRateLimitCounts();

        // Update Rate Limit Settings
        if (this.rpmLimitInput) this.rpmLimitInput.addEventListener('change', (e) => {
            this.RPM_LIMIT = parseInt(e.target.value) || 5;
            if (this.currentApiKeyId) {
                const apiKey = this.apiKeys.find(k => k.id === this.currentApiKeyId);
                if (apiKey) {
                    apiKey.rpmLimit = this.RPM_LIMIT;
                    this.saveApiKeys();
                }
            } else {
                localStorage.setItem('rpm_limit', this.RPM_LIMIT);
            }
            this.updateRateLimitDisplay();
        });

        if (this.rpdLimitInput) this.rpdLimitInput.addEventListener('change', (e) => {
            this.RPD_LIMIT = parseInt(e.target.value) || 20;
            if (this.currentApiKeyId) {
                const apiKey = this.apiKeys.find(k => k.id === this.currentApiKeyId);
                if (apiKey) {
                    apiKey.rpdLimit = this.RPD_LIMIT;
                    this.saveApiKeys();
                }
            } else {
                localStorage.setItem('rpd_limit', this.RPD_LIMIT);
            }
            this.updateRateLimitDisplay();
        });

        // Start Rate Limit Countdown Timer
        this.startRateLimitCountdown();

        // Export All Logs Button
        if (this.btnExportAll) {
            this.btnExportAll.addEventListener('click', () => this.exportAllLogs());
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
        if (this.btnLoadFile && this.audioFileInput) {
            this.btnLoadFile.addEventListener('click', () => this.audioFileInput.click());
            this.audioFileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        }

        // Update Model Display
        this.updateModelDisplay();

        // Settings Toggle
        if (this.settingsToggle) {
            this.settingsToggle.addEventListener('click', () => {
                this.settingsPanel.classList.toggle('open');
                this.settingsToggle.classList.toggle('active');
                const arrow = this.settingsToggle.querySelector('span:last-child');
                if (arrow) {
                    arrow.style.transform = this.settingsPanel.classList.contains('open') ? 'rotate(180deg)' : 'rotate(0deg)';
                }
            });
        }

        // API Key Management Panel Toggle
        const apiKeyToggle = document.getElementById('apiKeyToggle');
        const apiKeyPanel = document.getElementById('apiKeyPanel');
        if (apiKeyToggle && apiKeyPanel) {
            apiKeyToggle.addEventListener('click', () => {
                apiKeyPanel.classList.toggle('open');
                apiKeyToggle.classList.toggle('active');
                const arrow = apiKeyToggle.querySelector('span:last-child');
                if (arrow) {
                    arrow.style.transform = apiKeyPanel.classList.contains('open') ? 'rotate(180deg)' : 'rotate(0deg)';
                }
            });
        }

        // ãƒ“ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆï¼ˆéŒ²éŸ³ç”»é¢ â‡” è¨­å®šç”»é¢ï¼‰
        if (this.btnOpenSettings) {
            this.btnOpenSettings.addEventListener('click', () => this.showSettingsView());
        }
        if (this.btnBackToMain) {
            this.btnBackToMain.addEventListener('click', () => this.showMainView());
        }
    }

    showMainView() {
        const mainView = document.getElementById('main-view');
        const settingsView = document.getElementById('settings-view');
        if (mainView) mainView.classList.add('active');
        if (settingsView) settingsView.classList.remove('active');
    }

    showSettingsView() {
        const mainView = document.getElementById('main-view');
        const settingsView = document.getElementById('settings-view');
        if (mainView) mainView.classList.remove('active');
        if (settingsView) settingsView.classList.add('active');
    }

    /**
     * ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ã«éŸ³å£°ã‚’è¦ç´„å‡¦ç†
     */
    handleFileSelect(event) {
        const file = event.target.files?.[0];
        if (!file) return;

        const apiKey = this.getCurrentApiKey();
        if (!apiKey) {
            alert('APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚');
            this.showSettingsView();
            event.target.value = '';
            return;
        }

        const MAX_SIZE_MB = 18;
        if (file.size > MAX_SIZE_MB * 1024 * 1024) {
            alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™ã€‚${MAX_SIZE_MB}MBä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`);
            event.target.value = '';
            return;
        }

        const mimeType = file.type || 'audio/mp4';
        const supportedTypes = ['audio/mp4', 'audio/mpeg', 'audio/webm', 'audio/ogg', 'audio/wav', 'video/mp4'];
        const effectiveMime = supportedTypes.includes(mimeType) ? mimeType : 'audio/mp4';

        const segmentId = this.segmentCounter;
        this.processAudioSegment(file, segmentId, effectiveMime);
        this.segmentCounter++;
        if (this.segmentCounterDisplay) this.segmentCounterDisplay.textContent = this.segmentCounter;
        event.target.value = '';
    }

    /**
     * Starts the recording process.
     * Requests microphone access and sets up the MediaRecorder.
     */
    async startRecording() {
        const apiKey = this.getCurrentApiKey();
        if (!apiKey) {
            alert('APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚');
            this.showSettingsView();
            return;
        }

        let stream = null;
        try {
            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            // Setup MediaRecorder
            this.setupRecorder(stream);
            
            // â˜… ç”»é¢ã®å¸¸æ™‚ç‚¹ç¯ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            try {
                if ('wakeLock' in navigator) {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Screen Wake Lock active');
                }
            } catch (err) {
                console.error('Wake Lock error:', err);
            }
            
            // Startï¼ˆiOS Safariã§ã¯start()ãŒå¤±æ•—ã™ã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€timesliceä»˜ãã‚‚è©¦è¡Œï¼‰
            this.startWithTimeslice = false;
            try {
                this.mediaRecorder.start();
            } catch (startErr) {
                try {
                    this.mediaRecorder.start(1000);
                    this.startWithTimeslice = true;
                } catch (startErr2) {
                    stream.getTracks().forEach(t => t.stop());
                    throw new Error('éŒ²éŸ³é–‹å§‹ã«å¤±æ•—: ' + (startErr2.message || startErr2));
                }
            }
            this.isRecording = true;
            this.startTime = Date.now();
            this.updateUIState(true);
            this.startTimer();
            
            console.log(`Segment ${this.segmentCounter} started.`);

        } catch (err) {
            console.error('Error accessing microphone or starting recorder:', err);
            if (stream) stream.getTracks().forEach(t => t.stop());
            const msg = err && err.message ? err.message : String(err);
            alert('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã€ã¾ãŸã¯éŒ²éŸ³ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nè©³ç´°: ' + msg + '\n\nè¨­å®šã‚’ç¢ºèªã™ã‚‹ã‹ã€Safariã®é€šå¸¸ãƒ–ãƒ©ã‚¦ã‚¶ã§ãŠè©¦ã—ãã ã•ã„ã€‚');
        }
    }

    /**
     * Configures the MediaRecorder instance.
     * iOS Safari: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãªã—ã‚’æœ€å„ªå…ˆã€‚isTypeSupportedãŒæœªå®šç¾©ã®ã“ã¨ãŒã‚ã‚Šã€audio/webméå¯¾å¿œã€‚
     */
    setupRecorder(stream) {
        let mediaRecorder = null;
        let mimeType = 'audio/webm';

        // 1. æœ€å„ªå…ˆ: ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãªã—ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå½¢å¼ã‚’é¸æŠã€‚iOS Safariã§æœ‰åŠ¹ï¼‰
        try {
            mediaRecorder = new MediaRecorder(stream);
            mimeType = (mediaRecorder.mimeType && mediaRecorder.mimeType.length > 0) ? mediaRecorder.mimeType : 'audio/mp4';
        } catch (e) {
            console.warn('MediaRecorder(stream) failed:', e);
        }

        // 2. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ˜ç¤ºçš„ãªMIMEã‚¿ã‚¤ãƒ—
        if (!mediaRecorder) {
            for (const mt of ['audio/mp4', 'video/mp4', 'audio/webm']) {
                try {
                    if (typeof MediaRecorder.isTypeSupported === 'function' && !MediaRecorder.isTypeSupported(mt)) continue;
                    mediaRecorder = new MediaRecorder(stream, { mimeType: mt });
                    mimeType = mt;
                    break;
                } catch (e) {
                    console.warn(`MediaRecorder ${mt} failed:`, e);
                    continue;
                }
            }
        }
        if (!mediaRecorder) throw new Error('éŒ²éŸ³å½¢å¼ã‚’åˆæœŸåŒ–ã§ãã¾ã›ã‚“ã§ã—ãŸ');

        this.recordingMimeType = mimeType;
        this.mediaRecorder = mediaRecorder;
        this.audioChunks = [];

        this.mediaRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
                this.audioChunks.push(event.data);
            }
        };

        this.mediaRecorder.onstop = () => {
            // Create Blob from chunks (use same mime type as recording)
            const audioBlob = new Blob(this.audioChunks, { type: this.recordingMimeType });
            
            // Process this segment
            this.processAudioSegment(audioBlob, this.segmentCounter);

            // Prepare for next segment if we are essentially still "recording" (auto-split)
            if (this.isRecording) {
                this.segmentCounter++;
                this.audioChunks = [];
                this.startTime = Date.now(); // Reset timer base
                if (this.startWithTimeslice) {
                    this.mediaRecorder.start(1000);
                } else {
                    this.mediaRecorder.start();
                }
                console.log(`Segment ${this.segmentCounter} started (Auto-split).`);
            }
        };
    }

    /**
     * Stops the recording.
     * @param {boolean} fullStop - If true, stops completely. If false, it's a segment split.
     */
    stopRecording(fullStop = false) {
        if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') return;

        if (fullStop) {
            this.isRecording = false; // Stop the loop
            this.updateUIState(false);
            this.stopTimer();
            
            // â˜… å¸¸æ™‚ç‚¹ç¯ã‚’è§£é™¤ï¼ˆãƒãƒƒãƒ†ãƒªãƒ¼ç¯€ç´„ã®ãŸã‚ï¼‰
            if (this.wakeLock) {
                this.wakeLock.release()
                    .then(() => {
                        this.wakeLock = null;
                        console.log('Screen Wake Lock released');
                    });
            }
        }
        
        // This triggers onstop, which handles processing and potential restarting
        this.mediaRecorder.stop(); 
    }

    /**
     * Timer Logic: Updates display and checks for Auto-Split condition.
     */
    startTimer() {
        this.stopTimer(); // Clear existing
        this.timerInterval = setInterval(() => {
            const elapsed = Date.now() - this.startTime;
            
            // Update Display (MM:SS)
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            if (this.timerDisplay) this.timerDisplay.textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // Update Progress Bar
            const progress = Math.min((elapsed / this.SEGMENT_LIMIT_MS) * 100, 100);
            if (this.progressBar) this.progressBar.style.width = `${progress}%`;

            // Check Auto-Split Condition
            if (elapsed >= this.SEGMENT_LIMIT_MS) {
                console.log("Time limit reached. Auto-splitting...");
                this.stopRecording(false); // False means "don't fully stop, just split"
            }

        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) clearInterval(this.timerInterval);
        if (this.timerDisplay) this.timerDisplay.textContent = "00:00";
        if (this.progressBar) this.progressBar.style.width = "0%";
    }

    updateUIState(isRecording) {
        if (this.segmentCounterDisplay) this.segmentCounterDisplay.textContent = this.segmentCounter;
        if (this.mainView) {
            this.mainView.classList.remove('idle', 'recording');
            this.mainView.classList.add(isRecording ? 'recording' : 'idle');
        }
        if (this.micButton) {
            this.micButton.classList.remove('idle', 'recording');
            this.micButton.classList.add(isRecording ? 'recording' : 'idle');
        }
        if (this.timerBadge) {
            this.timerBadge.classList.toggle('hidden', !isRecording);
        }
    }

    /**
     * Update model display
     */
    updateModelDisplay() {
        if (this.modelDisplay) {
            this.modelDisplay.textContent = this.MODEL_NAME;
        }
        if (this.modelSelect) {
            this.modelSelect.value = this.MODEL_NAME;
        }
    }

    /**
     * API Key Management Methods
     */
    loadApiKeys() {
        const saved = localStorage.getItem('api_keys');
        if (saved) {
            return JSON.parse(saved);
        }
        return [];
    }

    saveApiKeys() {
        localStorage.setItem('api_keys', JSON.stringify(this.apiKeys));
    }

    initApiKeyManagement() {
        this.updateApiKeySelect();
        if (this.apiKeys.length > 0) {
            const lastUsed = localStorage.getItem('last_used_api_key_id');
            if (lastUsed && this.apiKeys.find(k => k.id === lastUsed)) {
                this.selectApiKey(lastUsed);
            } else {
                this.selectApiKey(this.apiKeys[0].id);
            }
        }
    }

    updateApiKeySelect() {
        if (!this.apiKeySelect) return;
        this.apiKeySelect.innerHTML = '<option value="">æ–°ã—ã„APIã‚­ãƒ¼ã‚’è¿½åŠ ...</option>';
        this.apiKeys.forEach(key => {
            const option = document.createElement('option');
            option.value = key.id;
            option.textContent = `${key.name} (${key.model || 'æœªè¨­å®š'})`;
            this.apiKeySelect.appendChild(option);
        });
    }

    addNewApiKey() {
        if (this.apiKeyInput) this.apiKeyInput.value = '';
        if (this.apiKeyNameInput) this.apiKeyNameInput.value = '';
        if (this.apiKeySelect) this.apiKeySelect.value = '';
        this.currentApiKeyId = null;
    }

    addApiKey(name, key, model = null) {
        const id = Date.now().toString();
        const apiKey = {
            id,
            name: name || 'APIã‚­ãƒ¼',
            key,
            model: model || 'gemini-2.5-flash',
            rpmLimit: 5,
            rpdLimit: 20
        };
        this.apiKeys.push(apiKey);
        this.saveApiKeys();
        this.updateApiKeySelect();
        this.selectApiKey(id);
        return id;
    }

    saveApiKey() {
        const key = this.apiKeyInput?.value?.trim() ?? '';
        const name = this.apiKeyNameInput?.value?.trim() || 'APIã‚­ãƒ¼';
        
        if (!key) {
            alert('APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            return;
        }

        if (this.currentApiKeyId) {
            // æ—¢å­˜ã®APIã‚­ãƒ¼ã‚’æ›´æ–°
            const apiKey = this.apiKeys.find(k => k.id === this.currentApiKeyId);
            if (apiKey) {
                apiKey.name = name;
                apiKey.key = key;
                apiKey.model = this.modelSelect?.value ?? 'gemini-2.5-flash';
                apiKey.rpmLimit = parseInt(this.rpmLimitInput?.value) || 5;
                apiKey.rpdLimit = parseInt(this.rpdLimitInput?.value) || 20;
            }
        } else {
            // æ–°ã—ã„APIã‚­ãƒ¼ã‚’è¿½åŠ 
            this.addApiKey(name, key, this.modelSelect?.value ?? 'gemini-2.5-flash');
        }
        
        this.saveApiKeys();
        this.updateApiKeySelect();
        alert('APIã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
    }

    deleteApiKey() {
        if (!this.currentApiKeyId) {
            alert('å‰Šé™¤ã™ã‚‹APIã‚­ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„');
            return;
        }

        if (!confirm('ã“ã®APIã‚­ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
            return;
        }

        this.apiKeys = this.apiKeys.filter(k => k.id !== this.currentApiKeyId);
        this.saveApiKeys();
        this.updateApiKeySelect();
        this.addNewApiKey();
        
        if (this.apiKeys.length > 0) {
            this.selectApiKey(this.apiKeys[0].id);
        }
    }

    selectApiKey(id) {
        if (!id) {
            this.addNewApiKey();
            return;
        }

        const apiKey = this.apiKeys.find(k => k.id === id);
        if (!apiKey) return;

        this.currentApiKeyId = id;
        if (this.apiKeyInput) this.apiKeyInput.value = apiKey.key;
        if (this.apiKeyNameInput) this.apiKeyNameInput.value = apiKey.name;
        if (this.apiKeySelect) this.apiKeySelect.value = id;
        if (this.modelSelect) this.modelSelect.value = apiKey.model || 'gemini-2.5-flash';
        if (this.rpmLimitInput) this.rpmLimitInput.value = apiKey.rpmLimit || 5;
        if (this.rpdLimitInput) this.rpdLimitInput.value = apiKey.rpdLimit || 20;
        
        this.MODEL_NAME = apiKey.model || 'gemini-2.5-flash';
        this.RPM_LIMIT = apiKey.rpmLimit || 5;
        this.RPD_LIMIT = apiKey.rpdLimit || 20;
        
        this.updateModelDisplay();
        this.updateRateLimitDisplay();
        
        localStorage.setItem('last_used_api_key_id', id);
    }

    getCurrentApiKey() {
        if (this.currentApiKeyId) {
            const apiKey = this.apiKeys.find(k => k.id === this.currentApiKeyId);
            if (apiKey) return apiKey.key;
        }
        return this.apiKeyInput?.value?.trim() ?? '';
    }

    updateModel(modelName) {
        this.MODEL_NAME = modelName;
        this.updateModelDisplay();
        if (this.currentApiKeyId) {
            const apiKey = this.apiKeys.find(k => k.id === this.currentApiKeyId);
            if (apiKey) {
                apiKey.model = modelName;
                this.saveApiKeys();
            }
        }
    }

    handleModeChange() {
        const selectedMode = document.querySelector('input[name="recordingMode"]:checked')?.value;
        
        if (selectedMode === 'secure') {
            // ç§˜åŒ¿æ€§ã®é«˜ã„ä¼šè­°ãƒ¢ãƒ¼ãƒ‰: è‡ªå‹•çš„ã«æœ‰æ–™APIã¨gemini-2.5-proã‚’é¸æŠ
            // æœ‰æ–™APIã‚­ãƒ¼ã‚’æ¢ã™ï¼ˆåå‰ã«ã€Œæœ‰æ–™ã€ã€Œpaidã€ã€Œproã€ãªã©ãŒå«ã¾ã‚Œã‚‹ï¼‰
            const paidApiKey = this.apiKeys.find(k => 
                k.name.toLowerCase().includes('æœ‰æ–™') || 
                k.name.toLowerCase().includes('paid') || 
                k.name.toLowerCase().includes('pro')
            );
            
            if (paidApiKey) {
                this.selectApiKey(paidApiKey.id);
            }
            
            // ãƒ¢ãƒ‡ãƒ«ã‚’gemini-2.5-proã«å¤‰æ›´
            if (this.modelSelect.value !== 'gemini-2.5-pro') {
                this.updateModel('gemini-2.5-pro');
            }
        }
    }

    /**
     * Gets the prompt template based on selected mode.
     */
    getPromptTemplate() {
        const selectedMode = document.querySelector('input[name="recordingMode"]:checked')?.value || 'meeting';
        
        const prompts = {
            secure: `
ã‚ãªãŸã¯å„ªç§€ãªä¼šè­°ã®æ›¸è¨˜å®˜ã§ã™ã€‚æä¾›ã•ã‚ŒãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã—ã€ä»¥ä¸‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å³æ ¼ã«å¾“ã£ã¦æ—¥æœ¬èªã§è­°äº‹éŒ²ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

# å½¹å‰²ã¨åˆ¶ç´„
- ã€Œãˆãƒ¼ã€ã€Œã‚ãƒ¼ã€ãªã©ã®ãƒ•ã‚£ãƒ©ãƒ¼ã‚„ã€ç„¡é–¢ä¿‚ãªé›‘è«‡ã¯é™¤å¤–ã™ã‚‹ã“ã¨ã€‚
- è©±è€…ãŒè¤‡æ•°ã„ã‚‹å ´åˆã¯ã€æ–‡è„ˆã‹ã‚‰æ¨æ¸¬ã—ã¦ç™ºè¨€ã®æ„å›³ã‚’æ±²ã¿å–ã‚‹ã“ã¨ã€‚
- å°‚é–€ç”¨èªã‚„å›ºæœ‰åè©ã¯å¯èƒ½ãªé™ã‚Šæ­£ç¢ºã«è¨˜è¿°ã™ã‚‹ã“ã¨ã€‚
- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§è¦‹ã‚„ã™ãæ•´å½¢ã™ã‚‹ã“ã¨ã€‚
- ç§˜åŒ¿æ€§ã®é«˜ã„ä¼šè­°ã®ãŸã‚ã€ç‰¹ã«æ©Ÿå¯†æƒ…å ±ã®å–ã‚Šæ‰±ã„ã«æ³¨æ„ã™ã‚‹ã“ã¨ã€‚

# å€‹äººæƒ…å ±ä¿è­·ï¼ˆå¿…é ˆãƒ»å¼·åŒ–ï¼‰
ä»¥ä¸‹ã®å€‹äººæƒ…å ±ã¯å¿…ãšå‰Šé™¤ã¾ãŸã¯åŒ¿ååŒ–ã—ã¦ãã ã•ã„ï¼š
- æ°åã€ãƒ•ãƒ«ãƒãƒ¼ãƒ ã€ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«ã€ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ï¼ˆã€ŒAã•ã‚“ã€ã€ŒBæ°ã€ãªã©ã«ç½®æ›ï¼‰
- ä½æ‰€ã€éƒµä¾¿ç•ªå·ã€å…·ä½“çš„ãªåœ°åï¼ˆã€Œâ—‹â—‹çœŒã€ã€Œâ—‹â—‹å¸‚ã€ãªã©ã«ç½®æ›ï¼‰
- é›»è©±ç•ªå·ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã€SNSã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
- ç”Ÿå¹´æœˆæ—¥ã€å¹´é½¢ï¼ˆã€Œ30ä»£ã€ã€Œ40ä»£ã€ãªã©ã«ç½®æ›ï¼‰
- ä¼šç¤¾åã€çµ„ç¹”åï¼ˆã€ŒAç¤¾ã€ã€ŒBçµ„ç¹”ã€ãªã©ã«ç½®æ›ï¼‰
- ãã®ä»–ã€å€‹äººã‚’ç‰¹å®šã§ãã‚‹æƒ…å ±

# å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
## ä¼šè­°æ¦‚è¦
- **æ—¥æ™‚**: [æ—¥æ™‚]
- **å‚åŠ è€…æ•°**: [äººæ•°]
- **ä¸»ãªè­°é¡Œ**: [è­°é¡Œã®è¦ç´„]

## è­°äº‹éŒ²
[æ™‚ç³»åˆ—ã§æ•´ç†ã•ã‚ŒãŸè­°äº‹éŒ²]

## æ±ºå®šäº‹é …
- [æ±ºå®šäº‹é …1]
- [æ±ºå®šäº‹é …2]

## ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ 
- [æ‹…å½“è€…ï¼ˆåŒ¿ååŒ–ï¼‰]: [ã‚¿ã‚¹ã‚¯å†…å®¹]
- [æ‹…å½“è€…ï¼ˆåŒ¿ååŒ–ï¼‰]: [ã‚¿ã‚¹ã‚¯å†…å®¹]

## æ¬¡å›äºˆå®š
[æ¬¡å›ä¼šè­°ã®äºˆå®šï¼ˆå€‹äººæƒ…å ±ã¯åŒ¿ååŒ–ï¼‰]
`,
            meeting: `
ã‚ãªãŸã¯å„ªç§€ãªä¼šè­°ã®æ›¸è¨˜å®˜ã§ã™ã€‚æä¾›ã•ã‚ŒãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã—ã€ä»¥ä¸‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å³æ ¼ã«å¾“ã£ã¦æ—¥æœ¬èªã§è­°äº‹éŒ²ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

# å½¹å‰²ã¨åˆ¶ç´„
- ã€Œãˆãƒ¼ã€ã€Œã‚ãƒ¼ã€ãªã©ã®ãƒ•ã‚£ãƒ©ãƒ¼ã‚„ã€ç„¡é–¢ä¿‚ãªé›‘è«‡ã¯é™¤å¤–ã™ã‚‹ã“ã¨ã€‚
- è©±è€…ãŒè¤‡æ•°ã„ã‚‹å ´åˆã¯ã€æ–‡è„ˆã‹ã‚‰æ¨æ¸¬ã—ã¦ç™ºè¨€ã®æ„å›³ã‚’æ±²ã¿å–ã‚‹ã“ã¨ã€‚
- å°‚é–€ç”¨èªã‚„å›ºæœ‰åè©ã¯å¯èƒ½ãªé™ã‚Šæ­£ç¢ºã«è¨˜è¿°ã™ã‚‹ã“ã¨ã€‚
- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§è¦‹ã‚„ã™ãæ•´å½¢ã™ã‚‹ã“ã¨ã€‚

# å€‹äººæƒ…å ±ä¿è­·ï¼ˆå¿…é ˆï¼‰
ä»¥ä¸‹ã®å€‹äººæƒ…å ±ã¯å¿…ãšå‰Šé™¤ã¾ãŸã¯åŒ¿ååŒ–ã—ã¦ãã ã•ã„ï¼š
- æ°åã€ãƒ•ãƒ«ãƒãƒ¼ãƒ ã€ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«ã€ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ï¼ˆã€ŒAã•ã‚“ã€ã€ŒBæ°ã€ãªã©ã«ç½®æ›ï¼‰
- ä½æ‰€ã€éƒµä¾¿ç•ªå·ã€å…·ä½“çš„ãªåœ°åï¼ˆã€Œâ—‹â—‹çœŒã€ã€Œâ—‹â—‹å¸‚ã€ãªã©ã«ç½®æ›ï¼‰
- é›»è©±ç•ªå·ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã€SNSã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
- ç”Ÿå¹´æœˆæ—¥ã€å¹´é½¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¹´ä»£ã®ã¿è¨˜è¼‰ï¼‰
- å‹¤å‹™å…ˆã€å­¦æ ¡åã€çµ„ç¹”åï¼ˆã€Œâ—‹â—‹ä¼šç¤¾ã€ã€Œâ—‹â—‹å¤§å­¦ã€ãªã©ã«ç½®æ›ï¼‰
- ãã®ä»–å€‹äººã‚’ç‰¹å®šã§ãã‚‹æƒ…å ±ï¼ˆIDç•ªå·ã€å…è¨±è¨¼ç•ªå·ãªã©ï¼‰
- å€‹äººæƒ…å ±ãŒå«ã¾ã‚Œã‚‹å ´åˆã¯ã€è©²å½“ç®‡æ‰€ã‚’ã€Œ[å€‹äººæƒ…å ±å‰Šé™¤]ã€ã¨è¨˜è¼‰ã™ã‚‹ã“ã¨

# å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

## 1. ğŸ¯ æ¦‚è¦ (Executive Summary)
ä¼šè­°ã®ç›®çš„ã¨ã€æ±ºå®šã•ã‚ŒãŸçµè«–ã‚’3è¡Œä»¥å†…ã§è¦ç´„ã—ã¦ãã ã•ã„ã€‚

## 2. ğŸ§  ä¸»è¦ãƒˆãƒ”ãƒƒã‚¯ (Mind Map Style)
è­°è«–ã•ã‚ŒãŸå†…å®¹ã‚’è«–ç†çš„ãªéšå±¤æ§‹é€ ï¼ˆç®‡æ¡æ›¸ãï¼‰ã§æ•´ç†ã—ã¦ãã ã•ã„ã€‚
- ãƒˆãƒ”ãƒƒã‚¯A
  - è©³ç´°äº‹å®Ÿ
  - è­°è«–ã®ãƒã‚¤ãƒ³ãƒˆ
- ãƒˆãƒ”ãƒƒã‚¯B
  - è©³ç´°äº‹å®Ÿ
  - æ‡¸å¿µç‚¹

## 3. âœ… æ±ºå®šäº‹é … (Decisions)
- [æ±ºå®š] ç¢ºå®šã—ãŸäº‹é …ã‚’ã“ã“ã«æ›¸ã
- [ä¿ç•™] ä¿ç•™ã¨ãªã£ãŸäº‹é …ã‚’ã“ã“ã«æ›¸ã

## 4. ğŸš€ ãƒã‚¯ã‚¹ãƒˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ (To-Do)
èª°ãŒã€ã„ã¤ã¾ã§ã«ã€ä½•ã‚’ã‚„ã‚‹ã‹ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚ä¸æ˜ãªå ´åˆã¯ã€Œæ‹…å½“è€…æœªå®šã€ã¨ã—ã¦ã‚¿ã‚¹ã‚¯ã®ã¿è¨˜è¼‰ã™ã‚‹ã“ã¨ã€‚
- [ ] ã‚¿ã‚¹ã‚¯å†…å®¹ (æ‹…å½“: ã€‡ã€‡ / æœŸé™: ã€‡ã€‡)

---
(ä»¥ä¸‹ã€éŸ³å£°ãŒé€”ä¸­ã‹ã‚‰å§‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯æ–‡è„ˆã‚’è£œå®Œã—ã¦è¦ç´„ã—ã¦ãã ã•ã„)
`,
            medical: `
ã‚ãªãŸã¯ç†Ÿç·´ã—ãŸåŒ»ç™‚ã‚¯ãƒ©ãƒ¼ã‚¯ã§ã™ã€‚åŒ»å¸«ã«ã‚ˆã‚‹æ‚£è€…ãƒ»å®¶æ—ã¸ã®ç—…çŠ¶èª¬æ˜ï¼ˆã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ãƒ‰ãƒ»ã‚³ãƒ³ã‚»ãƒ³ãƒˆï¼‰ã®éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã—ã€é›»å­ã‚«ãƒ«ãƒ†ã«ãã®ã¾ã¾è»¢è¨˜ã§ãã‚‹å½¢å¼ã§è¦ç´„ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

# å½¹å‰²ã¨é‡è¦äº‹é …
- **ç›®çš„**: èª¬æ˜å†…å®¹ã®è¨˜éŒ²ãŠã‚ˆã³ã€æ‚£è€…ãƒ»å®¶æ—ã®ã€Œç†è§£åº¦ã€ã¨ã€ŒåŒæ„ã€ã®æœ‰ç„¡ã‚’æ˜ç¢ºã«ã™ã‚‹ã“ã¨ã€‚
- **ç”¨èª**: å°‚é–€ç”¨èªã¯æ­£ç¢ºã«æ¼¢å­—ãƒ»è‹±èªã§è¨˜è¼‰ã™ã‚‹ã“ã¨ï¼ˆä¾‹: å¿ƒä¸å…¨â†’HFã€è‚ºç‚â†’Pneumoniaï¼‰ã€‚
- **é™¤å¤–**: ã€Œã‚ãƒ¼ã€ã€Œãˆãƒ¼ã€ãªã©ã®ãƒ•ã‚£ãƒ©ãƒ¼ã€ç„¡é–¢ä¿‚ãªä¸–é–“è©±ã€‚
- **æ¨è«–**: èª°ãŒã‚­ãƒ¼ãƒ‘ãƒ¼ã‚½ãƒ³ï¼ˆæ±ºå®šæ¨©è€…ï¼‰ã‹ã‚’æ–‡è„ˆã‹ã‚‰æ¨æ¸¬ã—ã€ãã®ç™ºè¨€ã‚’é‡è¦–ã™ã‚‹ã“ã¨ã€‚

# å€‹äººæƒ…å ±ä¿è­·ï¼ˆå¿…é ˆãƒ»æœ€é‡è¦ï¼‰
ä»¥ä¸‹ã®å€‹äººæƒ…å ±ã¯å¿…ãšå‰Šé™¤ã¾ãŸã¯åŒ¿ååŒ–ã—ã¦ãã ã•ã„ï¼š
- æ‚£è€…ãƒ»å®¶æ—ã®æ°åï¼ˆã€Œæœ¬äººã€ã€Œé•·ç”·ã€ã€Œå¦»ã€ãªã©ã«ç½®æ›ï¼‰
- å…·ä½“çš„ãªåœ°åã€ç—…é™¢åã€æ—¥ä»˜ï¼ˆã€Œå½“é™¢ã€ã€ŒXæ—¥ã€ãªã©ã«ç½®æ›ï¼‰

# å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

## 1. ğŸ‘¥ å‚åŠ è€… (Participants)
- **èª¬æ˜è€…**: [åŒ»å¸«å/è·ç¨®]ã€[åŒå¸­çœ‹è­·å¸«ãªã©]
- **å¯¾è±¡è€…**: [æœ¬äºº]ã€[ã‚­ãƒ¼ãƒ‘ãƒ¼ã‚½ãƒ³ï¼ˆç¶šæŸ„ï¼‰]ã€[ãã®ä»–åŒå¸­è€…]

## 2. ğŸ“‹ èª¬æ˜å†…å®¹ (Explanation Summary)
åŒ»å¸«ãŒèª¬æ˜ã—ãŸä»¥ä¸‹ã®é …ç›®ã‚’ç°¡æ½”ã«ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚
- **ç¾åœ¨ã®ç—…çŠ¶ãƒ»è¨ºæ–­**: [è¨ºæ–­åã¨ç¾çŠ¶]
- **ææ¡ˆã•ã‚ŒãŸæ²»ç™‚ãƒ»æ–¹é‡**: [æ²»ç™‚å†…å®¹]
- **ãƒ¡ãƒªãƒƒãƒˆãƒ»æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ**: [å†…å®¹]
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆãƒ»ãƒªã‚¹ã‚¯ãƒ»åˆä½µç—‡**: [å…·ä½“çš„ãªãƒªã‚¹ã‚¯]
- **ä»£æ›¿æ¡ˆã®æç¤º**: [ã‚ã‚Œã°è¨˜è¼‰ã€ãªã‘ã‚Œã°ã€Œãªã—ã€]

## 3. ğŸ—£ï¸ è³ªç–‘å¿œç­”ã¨åå¿œ (Q&A & Reaction)
ã“ã“ãŒæœ€ã‚‚é‡è¦ã§ã™ã€‚å®¶æ—ã‹ã‚‰ã®è³ªå•ã¨ã€ãã‚Œã«å¯¾ã™ã‚‹å›ç­”ã€ãŠã‚ˆã³å®¶æ—ã®æ„Ÿæƒ…çš„ãªåå¿œï¼ˆç´å¾—ã€ä¸å®‰ã€æ‹’çµ¶ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚
- **è³ªå•**: [å®¶æ—ã®è³ªå•å†…å®¹]
  - **å›ç­”**: [åŒ»å¸«ã®å›ç­”]
- **å®¶æ—ã®åå¿œ**: [ã€Œç†è§£ã—ãŸæ§˜å­ã€ã€Œå¼·ã„ä¸å®‰ã‚’ç¤ºã—ãŸã€ã€ŒæŒã¡å¸°ã£ã¦æ¤œè¨ã—ãŸã„ã€ãªã©]

## 4. âœ… çµè«– (Conclusion)
- [ ] æ–¹é‡ã«åŒæ„ï¼ˆç½²åå–å¾—/å£é ­åŒæ„ï¼‰
- [ ] æŒã¡å¸°ã£ã¦æ¤œè¨
- [ ] ã‚»ã‚«ãƒ³ãƒ‰ã‚ªãƒ”ãƒ‹ã‚ªãƒ³å¸Œæœ›
- [ ] ãã®ä»–: [è©³ç´°]

## 5. ğŸ“ è£œè¶³ãƒ»ç‰¹è¨˜äº‹é …
ï¼ˆéŒ²éŸ³çŠ¶æ³ãŒæ‚ªã‹ã£ãŸå ´åˆã‚„ã€ç‰¹ã«è¨˜éŒ²ã—ã¦ãŠãã¹ããƒˆãƒ©ãƒ–ãƒ«ã®äºˆå…†ãªã©ï¼‰

---
(ä»¥ä¸‹ã€éŸ³å£°ãŒé€”ä¸­ã‹ã‚‰å§‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯æ–‡è„ˆã‚’è£œå®Œã—ã¦è¨˜éŒ²ã—ã¦ãã ã•ã„)
`,
            patient: `
ã‚ãªãŸã¯å„ªç§€ãªåŒ»ç™‚è¨˜éŒ²ã®å°‚é–€å®¶ã§ã™ã€‚æä¾›ã•ã‚ŒãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã—ã€ä»¥ä¸‹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å³æ ¼ã«å¾“ã£ã¦æ—¥æœ¬èªã§å‚·ç—…è€…æƒ…å ±ã‚’æ•´ç†ã—ã¦ãã ã•ã„ã€‚

# å½¹å‰²ã¨åˆ¶ç´„
- ã€Œãˆãƒ¼ã€ã€Œã‚ãƒ¼ã€ãªã©ã®ãƒ•ã‚£ãƒ©ãƒ¼ã‚„ã€ç„¡é–¢ä¿‚ãªé›‘è«‡ã¯é™¤å¤–ã™ã‚‹ã“ã¨ã€‚
- åŒ»ç™‚æƒ…å ±ã¯æ­£ç¢ºã«è¨˜éŒ²ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ãŒã€å€‹äººã‚’ç‰¹å®šã§ãã‚‹æƒ…å ±ã¯ä¸€åˆ‡è¨˜éŒ²ã—ãªã„ã“ã¨ã€‚
- ç·Šæ€¥æ€§ã®åˆ¤æ–­ã«å¿…è¦ãªæƒ…å ±ã‚’å„ªå…ˆçš„ã«æŠ½å‡ºã™ã‚‹ã“ã¨ã€‚
- ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã§è¦‹ã‚„ã™ãæ•´å½¢ã™ã‚‹ã“ã¨ã€‚

# å€‹äººæƒ…å ±ä¿è­·ï¼ˆå¿…é ˆãƒ»æœ€é‡è¦ï¼‰
ä»¥ä¸‹ã®å€‹äººæƒ…å ±ã¯å¿…ãšå‰Šé™¤ã¾ãŸã¯åŒ¿ååŒ–ã—ã¦ãã ã•ã„ï¼š
- å‚·ç—…è€…ã®æ°åã€ãƒ•ãƒ«ãƒãƒ¼ãƒ ã€ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«ï¼ˆã€Œå‚·ç—…è€…Aã€ã€Œå‚·ç—…è€…Bã€ãªã©ã«ç½®æ›ï¼‰
- ä½æ‰€ã€éƒµä¾¿ç•ªå·ã€å…·ä½“çš„ãªåœ°åï¼ˆã€Œâ—‹â—‹çœŒã€ã€Œâ—‹â—‹å¸‚ã€ãªã©ã«ç½®æ›ï¼‰
- é›»è©±ç•ªå·ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã€é€£çµ¡å…ˆæƒ…å ±
- ç”Ÿå¹´æœˆæ—¥ã€å¹´é½¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¹´ä»£ã®ã¿è¨˜è¼‰ã€ä¾‹ï¼šã€Œ30ä»£å¥³æ€§ã€ï¼‰
- å‹¤å‹™å…ˆã€å­¦æ ¡åã€çµ„ç¹”åï¼ˆã€Œâ—‹â—‹ä¼šç¤¾ã€ã€Œâ—‹â—‹å¤§å­¦ã€ãªã©ã«ç½®æ›ï¼‰
- æ‚£è€…IDã€ã‚«ãƒ«ãƒ†ç•ªå·ã€ãã®ä»–è­˜åˆ¥ç•ªå·
- å®¶æ—æ§‹æˆã‚„å®¶æ—ã®å€‹äººæƒ…å ±
- ãã®ä»–å€‹äººã‚’ç‰¹å®šã§ãã‚‹æƒ…å ±
- å€‹äººæƒ…å ±ãŒå«ã¾ã‚Œã‚‹å ´åˆã¯ã€è©²å½“ç®‡æ‰€ã‚’ã€Œ[å€‹äººæƒ…å ±å‰Šé™¤]ã€ã¨è¨˜è¼‰ã™ã‚‹ã“ã¨
- åŒ»ç™‚æƒ…å ±ï¼ˆç—‡çŠ¶ã€çŠ¶æ…‹ãªã©ï¼‰ã¯è¨˜éŒ²ã—ã¾ã™ãŒã€å€‹äººã‚’ç‰¹å®šã§ãã‚‹æƒ…å ±ã¯ä¸€åˆ‡å«ã‚ãªã„ã“ã¨

# å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

## 1. ğŸ‘¤ åŸºæœ¬æƒ…å ± (Basic Information)
- å¹´é½¢ãƒ»æ€§åˆ¥ï¼ˆè¨€åŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
- å—å‚·ãƒ»ç™ºç—‡ã®æ—¥æ™‚ãƒ»å ´æ‰€
- çŠ¶æ³ãƒ»çµŒç·¯

## 2. ğŸš¨ ç¾çŠ¶ãƒ»ç—‡çŠ¶ (Current Condition / Symptoms)
- ç¾åœ¨ã®çŠ¶æ…‹ï¼ˆæ„è­˜ãƒ¬ãƒ™ãƒ«ã€ãƒã‚¤ã‚¿ãƒ«ã‚µã‚¤ãƒ³ãªã©ï¼‰
- ä¸»ãªç—‡çŠ¶ãƒ»è¨´ãˆ
- å¤–å‚·ã®æœ‰ç„¡ã¨ãã®è©³ç´°ï¼ˆéƒ¨ä½ã€ç¨‹åº¦ï¼‰

## 3. ğŸ¥ æ—¢å¾€æ­´ãƒ»ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼ (Medical History / Allergies)
- æ—¢å¾€ç–¾æ‚£ï¼ˆè¨€åŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
- ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼æ­´ï¼ˆè–¬å‰¤ã€é£Ÿç‰©ãªã©ï¼‰
- å¸¸ç”¨è–¬ï¼ˆè¨€åŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰

## 4. âš ï¸ ç·Šæ€¥åº¦ãƒ»å¯¾å¿œ (Urgency / Response)
- ç·Šæ€¥åº¦ã®è©•ä¾¡
- å¿…è¦ãªå¯¾å¿œãƒ»å‡¦ç½®
- æ¬é€å…ˆãƒ»å—è¨ºå…ˆã®æƒ…å ±ï¼ˆè¨€åŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰

## 5. ğŸ“ ãã®ä»– (Additional Information)
ãã®ä»–ã€é‡è¦ãªæƒ…å ±ãŒã‚ã‚Œã°è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚

---
(ä»¥ä¸‹ã€éŸ³å£°ãŒé€”ä¸­ã‹ã‚‰å§‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯æ–‡è„ˆã‚’è£œå®Œã—ã¦è¦ç´„ã—ã¦ãã ã•ã„)
`
        };
        
        return prompts[selectedMode] || prompts.meeting;
    }

    /**
     * Check if rate limit is exceeded
     */
    checkRateLimit() {
        const now = Date.now();
        
        // Check RPM
        if (this.rpmResetTime && now < this.rpmResetTime) {
            if (this.rpmCount >= this.RPM_LIMIT) {
                const waitTime = Math.ceil((this.rpmResetTime - now) / 1000);
                throw new Error(`RPMåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚${waitTime}ç§’å¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚`);
            }
        } else {
            // Reset RPM counter
            this.rpmCount = 0;
            this.rpmResetTime = now + 60 * 1000; // 1åˆ†å¾Œ
        }

        // Check RPD
        if (this.rpdResetTime && now < this.rpdResetTime) {
            if (this.rpdCount >= this.RPD_LIMIT) {
                const waitTime = Math.ceil((this.rpdResetTime - now) / 1000);
                const waitHours = Math.floor(waitTime / 3600);
                const waitMinutes = Math.floor((waitTime % 3600) / 60);
                throw new Error(`RPDåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚${waitHours}æ™‚é–“${waitMinutes}åˆ†å¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚`);
            }
        } else {
            // Reset RPD counter (next midnight)
            const tomorrow = new Date();
            tomorrow.setHours(24, 0, 0, 0);
            this.rpdResetTime = tomorrow.getTime();
            this.rpdCount = 0;
        }

        return true;
    }

    /**
     * Increment rate limit counters
     */
    incrementRateLimit() {
        this.rpmCount++;
        this.rpdCount++;
        this.saveRateLimitCounts();
        this.updateRateLimitDisplay();
    }

    /**
     * Load rate limit counts from localStorage
     */
    loadRateLimitCounts() {
        const saved = localStorage.getItem('rate_limit_counts');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                const now = Date.now();
                
                // Check if RPM reset time has passed
                if (data.rpmResetTime && now >= data.rpmResetTime) {
                    this.rpmCount = 0;
                    this.rpmResetTime = now + 60 * 1000;
                } else {
                    this.rpmCount = data.rpmCount || 0;
                    this.rpmResetTime = data.rpmResetTime || (now + 60 * 1000);
                }

                // Check if RPD reset time has passed
                if (data.rpdResetTime && now >= data.rpdResetTime) {
                    this.rpdCount = 0;
                    const tomorrow = new Date();
                    tomorrow.setHours(24, 0, 0, 0);
                    this.rpdResetTime = tomorrow.getTime();
                } else {
                    this.rpdCount = data.rpdCount || 0;
                    this.rpdResetTime = data.rpdResetTime || (() => {
                        const tomorrow = new Date();
                        tomorrow.setHours(24, 0, 0, 0);
                        return tomorrow.getTime();
                    })();
                }
            } catch (e) {
                console.error('Failed to load rate limit counts:', e);
            }
        } else {
            // Initialize
            const now = Date.now();
            this.rpmResetTime = now + 60 * 1000;
            const tomorrow = new Date();
            tomorrow.setHours(24, 0, 0, 0);
            this.rpdResetTime = tomorrow.getTime();
        }
        this.updateRateLimitDisplay();
    }

    /**
     * Save rate limit counts to localStorage
     */
    saveRateLimitCounts() {
        const data = {
            rpmCount: this.rpmCount,
            rpdCount: this.rpdCount,
            rpmResetTime: this.rpmResetTime,
            rpdResetTime: this.rpdResetTime
        };
        localStorage.setItem('rate_limit_counts', JSON.stringify(data));
    }

    /**
     * Update rate limit display
     */
    updateRateLimitDisplay() {
        if (!this.rateLimitPanel) return;

        // Update counts
        this.rpmCountDisplay.textContent = `${this.rpmCount}/${this.RPM_LIMIT}`;
        this.rpdCountDisplay.textContent = `${this.rpdCount}/${this.RPD_LIMIT}`;

        // Calculate percentages
        const rpmPercent = (this.rpmCount / this.RPM_LIMIT) * 100;
        const rpdPercent = (this.rpdCount / this.RPD_LIMIT) * 100;

        // Update progress bars
        if (this.rpmProgressBar) {
            this.rpmProgressBar.style.width = `${Math.min(rpmPercent, 100)}%`;
            this.rpmProgressBar.classList.remove('warning', 'danger');
            if (rpmPercent >= 90) {
                this.rpmProgressBar.classList.add('danger');
            } else if (rpmPercent >= 70) {
                this.rpmProgressBar.classList.add('warning');
            }
        }

        if (this.rpdProgressBar) {
            this.rpdProgressBar.style.width = `${Math.min(rpdPercent, 100)}%`;
            this.rpdProgressBar.classList.remove('warning', 'danger');
            if (rpdPercent >= 90) {
                this.rpdProgressBar.classList.add('danger');
            } else if (rpdPercent >= 70) {
                this.rpdProgressBar.classList.add('warning');
            }
        }

        // Update panel colors
        if (rpmPercent >= 90 || rpdPercent >= 90) {
            this.rateLimitPanel.className = 'rate-limit-panel danger';
        } else if (rpmPercent >= 70 || rpdPercent >= 70) {
            this.rateLimitPanel.className = 'rate-limit-panel warning';
        } else {
            this.rateLimitPanel.className = 'rate-limit-panel';
        }

        // Show panel if there are any requests
        if (this.rpmCount > 0 || this.rpdCount > 0) {
            this.rateLimitPanel.style.display = 'block';
        }
    }

    /**
     * Start rate limit countdown timer
     */
    startRateLimitCountdown() {
        if (this.rateLimitInterval) {
            clearInterval(this.rateLimitInterval);
        }

        this.rateLimitInterval = setInterval(() => {
            const now = Date.now();
            
            // RPM countdown
            if (this.rpmResetTime && now < this.rpmResetTime) {
                const seconds = Math.ceil((this.rpmResetTime - now) / 1000);
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                this.rpmCountdownTime.textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
                this.rpmCountdownDisplay.style.display = 'flex';
            } else {
                this.rpmCountdownDisplay.style.display = 'none';
            }

            // RPD countdown
            if (this.rpdResetTime && now < this.rpdResetTime) {
                const seconds = Math.ceil((this.rpdResetTime - now) / 1000);
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                this.rpdCountdownTime.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                this.rpdCountdownDisplay.style.display = 'flex';
            } else {
                this.rpdCountdownDisplay.style.display = 'none';
            }

            this.updateRateLimitDisplay();
        }, 1000);
    }

    /**
     * IndexedDB: éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç”¨DBã‚’åˆæœŸåŒ–
     */
    initAudioDB() {
        if (this.audioDB) return Promise.resolve();
        return new Promise((resolve) => {
            try {
                const req = indexedDB.open(this.AUDIO_DB_NAME, 1);
                req.onerror = () => {
                    console.warn('[IndexedDB] open failed:', req.error);
                    resolve();
                };
                req.onsuccess = () => {
                    this.audioDB = req.result;
                    console.log('[IndexedDB] initialized');
                    resolve();
                };
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(this.AUDIO_STORE_NAME)) {
                        db.createObjectStore(this.AUDIO_STORE_NAME, { keyPath: 'logId' });
                    }
                };
            } catch (e) {
                console.warn('[IndexedDB] not available:', e);
                resolve();
            }
        });
    }

    /**
     * IndexedDB: éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆAPIå¤±æ•—æ™‚ã®å†é€ä¿¡ç”¨ï¼‰
     */
    async saveAudioToIndexedDB(logId, blob, mimeType) {
        if (!indexedDB || !blob) {
            console.warn('[IndexedDB] save skipped: indexedDB or blob missing');
            return;
        }
        await this.initAudioDB();
        if (!this.audioDB) {
            console.warn('[IndexedDB] save skipped: DB not available');
            return;
        }
        return new Promise((resolve) => {
            const tx = this.audioDB.transaction(this.AUDIO_STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.AUDIO_STORE_NAME);
            const reader = new FileReader();
            reader.onloadend = () => {
                store.put({ logId, arrayBuffer: reader.result, mimeType: mimeType || this.recordingMimeType });
                tx.oncomplete = () => {
                    console.log('[IndexedDB] saved:', logId, `(${(blob.size / 1024).toFixed(1)}KB)`);
                    resolve();
                };
                tx.onerror = () => {
                    console.warn('[IndexedDB] save error:', tx.error);
                    resolve();
                };
            };
            reader.onerror = () => {
                console.warn('[IndexedDB] FileReader error:', reader.error);
                resolve();
            };
            reader.readAsArrayBuffer(blob);
        });
    }

    /**
     * IndexedDB: éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
     */
    async getAudioFromIndexedDB(logId) {
        if (!indexedDB) return null;
        await this.initAudioDB();
        if (!this.audioDB) return null;
        return new Promise((resolve) => {
            const tx = this.audioDB.transaction(this.AUDIO_STORE_NAME, 'readonly');
            const store = tx.objectStore(this.AUDIO_STORE_NAME);
            const req = store.get(logId);
            req.onsuccess = () => {
                const data = req.result;
                if (!data || !data.arrayBuffer) {
                    console.log('[IndexedDB] get: not found:', logId);
                    return resolve(null);
                }
                console.log('[IndexedDB] get:', logId);
                resolve({
                    blob: new Blob([data.arrayBuffer], { type: data.mimeType || 'audio/webm' }),
                    mimeType: data.mimeType || 'audio/webm'
                });
            };
            req.onerror = () => {
                console.warn('[IndexedDB] get error:', req.error);
                resolve(null);
            };
        });
    }

    /**
     * IndexedDB: éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆè¦ç´„æˆåŠŸæ™‚ï¼‰
     */
    async deleteAudioFromIndexedDB(logId) {
        if (!indexedDB) return;
        await this.initAudioDB();
        if (!this.audioDB) return;
        return new Promise((resolve) => {
            const tx = this.audioDB.transaction(this.AUDIO_STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.AUDIO_STORE_NAME);
            store.delete(logId);
            tx.oncomplete = () => {
                console.log('[IndexedDB] deleted:', logId);
                resolve();
            };
            tx.onerror = () => resolve();
        });
    }

    /**
     * éŸ³å£°ã‚’Gemini APIã«é€ä¿¡ã—ã€è¦ç´„ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™ï¼ˆå†…éƒ¨ç”¨ï¼‰
     */
    async executeAudioApiCall(blob, mimeType) {
        this.checkRateLimit();
        const base64Audio = await this.blobToBase64(blob);
        const apiKey = this.getCurrentApiKey();
        if (!apiKey) throw new Error('APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.MODEL_NAME}:generateContent?key=${apiKey}`;
        const promptText = this.getPromptTemplate();
        const payload = {
            contents: [{
                parts: [
                    { text: promptText },
                    { inline_data: { mime_type: mimeType, data: base64Audio } }
                ]
            }]
        };
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        const data = await response.json().catch(() => ({}));
        if (data.error) throw new Error(data.error.message || String(data.error));
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${data.error?.message || response.statusText || 'Unknown error'}`);
        this.incrementRateLimit();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!text) throw new Error(data.error?.message || 'APIå¿œç­”ã®å½¢å¼ãŒä¸æ­£ã§ã™');
        return text;
    }

    /**
     * Sends audio to Gemini API and displays result.
     * @param {Blob} blob - éŸ³å£°ãƒ‡ãƒ¼ã‚¿
     * @param {number} segmentId - ã‚»ã‚°ãƒ¡ãƒ³ãƒˆç•ªå·
     * @param {string} [mimeTypeOverride] - ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æ™‚ã®MIMEã‚¿ã‚¤ãƒ—ï¼ˆçœç•¥æ™‚ã¯recordingMimeTypeã‚’ä½¿ç”¨ï¼‰
     */
    async processAudioSegment(blob, segmentId, mimeTypeOverride) {
        // Create UI Log Entry
        const logId = `log-${segmentId}`;
        const timestamp = new Date().toLocaleTimeString();
        
        const logHtml = `
            <div class="log-entry" id="${logId}">
                <div class="log-header">
                    <strong>ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ #${segmentId}</strong>
                    <span>${timestamp}</span>
                </div>
                <div class="log-content loading">Geminiã¸é€ä¿¡ä¸­... éŸ³å£°å‡¦ç†ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™...</div>
                <div class="log-actions" style="display: none;">
                    <button class="log-action-btn copy" onclick="app.copyLog('${logId}', this)">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
                    <button class="log-action-btn save" onclick="app.saveLog('${logId}', ${segmentId}, '${timestamp}')">ğŸ’¾ ä¿å­˜</button>
                    <button class="log-action-btn share" onclick="app.shareLog('${logId}', ${segmentId}, '${timestamp}')">ğŸ”— å…±æœ‰</button>
                </div>
                <div class="log-retry-actions" style="display: none;">
                    <button class="log-action-btn retry" onclick="app.retryAudioSegment('${logId}')">ğŸ”„ å†é€ä¿¡</button>
                </div>
            </div>
        `;
        this.logsContainer.insertAdjacentHTML('afterbegin', logHtml);
        const contentDiv = document.querySelector(`#${logId} .log-content`);
        const mimeType = mimeTypeOverride || this.recordingMimeType || 'audio/webm';

        // IndexedDBã«éŸ³å£°ã‚’ä¿å­˜ï¼ˆAPIå¤±æ•—æ™‚ã®å†é€ä¿¡ç”¨ï¼‰
        await this.saveAudioToIndexedDB(logId, blob, mimeType);

        try {
            const markdown = await this.executeAudioApiCall(blob, mimeType);
            contentDiv.classList.remove('loading');
            contentDiv.innerHTML = this.simpleMarkdownParse(markdown); // Simple format for prototype
            
            // Show action buttons after content is loaded
            const actionsDiv = document.querySelector(`#${logId} .log-actions`);
            if (actionsDiv) {
                actionsDiv.style.display = 'flex';
            }
            
            // Store raw markdown for export
            contentDiv.dataset.rawMarkdown = markdown;

            // è¦ç´„æˆåŠŸ: IndexedDBã‹ã‚‰éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
            await this.deleteAudioFromIndexedDB(logId);

        } catch (err) {
            contentDiv.classList.remove('loading');
            contentDiv.classList.add('error');
            contentDiv.textContent = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${err.message}`;
            console.error('[processAudioSegment]', err);
            // ã‚¨ãƒ©ãƒ¼æ™‚: å†é€ä¿¡ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºï¼ˆéŸ³å£°ã¯IndexedDBã«ä¿æŒæ¸ˆã¿ï¼‰
            const retryDiv = document.querySelector(`#${logId} .log-retry-actions`);
            if (retryDiv) retryDiv.style.display = 'flex';
        }
    }

    /**
     * å¤±æ•—ã—ãŸã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®éŸ³å£°ã‚’IndexedDBã‹ã‚‰å–å¾—ã—ã¦å†é€ä¿¡
     */
    async retryAudioSegment(logId) {
        const contentDiv = document.querySelector(`#${logId} .log-content`);
        const retryDiv = document.querySelector(`#${logId} .log-retry-actions`);
        if (!contentDiv || !retryDiv) {
            console.warn('[retry] element not found:', logId);
            return;
        }

        console.log('[retry] fetching audio for:', logId);
        const stored = await this.getAudioFromIndexedDB(logId);
        if (!stored) {
            contentDiv.textContent = 'éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚éŒ²éŸ³ã—ç›´ã—ã¦ãã ã•ã„ã€‚';
            console.warn('[retry] audio not found in IndexedDB');
            return;
        }

        // å†é€ä¿¡ä¸­UI
        contentDiv.classList.remove('error');
        contentDiv.classList.add('loading');
        contentDiv.textContent = 'å†é€ä¿¡ä¸­...';
        retryDiv.style.display = 'none';
        const retryBtn = retryDiv.querySelector('.retry');
        if (retryBtn) retryBtn.disabled = true;

        try {
            const markdown = await this.executeAudioApiCall(stored.blob, stored.mimeType);
            contentDiv.classList.remove('loading');
            contentDiv.innerHTML = this.simpleMarkdownParse(markdown);
            contentDiv.dataset.rawMarkdown = markdown;
            const actionsDiv = document.querySelector(`#${logId} .log-actions`);
            if (actionsDiv) actionsDiv.style.display = 'flex';
            await this.deleteAudioFromIndexedDB(logId);
        } catch (e) {
            contentDiv.classList.remove('loading');
            contentDiv.classList.add('error');
            contentDiv.textContent = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`;
            retryDiv.style.display = 'flex';
            if (retryBtn) retryBtn.disabled = false;
            console.error('[retry]', e);
        }
    }

    // Helper: Convert Blob to Base64 (strip header)
    blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                const result = reader.result;
                if (!result || typeof result !== 'string') return reject(new Error('Blobã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'));
                const base64String = result.split(',')[1];
                resolve(base64String || '');
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    // Helper: Very simple Markdown to HTML for display
    simpleMarkdownParse(text) {
        return text
            .replace(/^# (.*$)/gim, '<strong>$1</strong>')
            .replace(/^## (.*$)/gim, '<strong>$1</strong>')
            .replace(/^\* (.*$)/gim, 'â€¢ $1')
            .replace(/\n/g, '<br>');
    }

    /**
     * Copy log content to clipboard
     */
    async copyLog(logId, buttonElement) {
        try {
            const logEntry = document.getElementById(logId);
            if (!logEntry) return;

            const contentDiv = logEntry.querySelector('.log-content');
            const rawMarkdown = contentDiv.dataset.rawMarkdown || contentDiv.textContent;
            
            await navigator.clipboard.writeText(rawMarkdown);
            
            // Show feedback
            if (buttonElement) {
                const originalText = buttonElement.textContent;
                buttonElement.textContent = 'âœ“ ã‚³ãƒ”ãƒ¼æ¸ˆã¿';
                buttonElement.style.background = '#d4edda';
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.style.background = '';
                }, 2000);
            }
        } catch (err) {
            console.error('Failed to copy:', err);
            alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }

    /**
     * Save log as text file
     */
    saveLog(logId, segmentId, timestamp) {
        try {
            const logEntry = document.getElementById(logId);
            if (!logEntry) return;

            const contentDiv = logEntry.querySelector('.log-content');
            const rawMarkdown = contentDiv.dataset.rawMarkdown || contentDiv.textContent;
            
            const filename = `è¦ç´„_ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ${segmentId}_${timestamp.replace(/:/g, '-')}.txt`;
            const blob = new Blob([rawMarkdown], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (err) {
            console.error('Failed to save:', err);
            alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }

    /**
     * Share log as JSON file (includes metadata)
     */
    shareLog(logId, segmentId, timestamp) {
        try {
            const logEntry = document.getElementById(logId);
            if (!logEntry) return;

            const contentDiv = logEntry.querySelector('.log-content');
            const rawMarkdown = contentDiv.dataset.rawMarkdown || contentDiv.textContent;
            
            const logData = {
                segmentId: segmentId,
                timestamp: timestamp,
                date: new Date().toISOString(),
                mode: document.querySelector('input[name="recordingMode"]:checked')?.value || 'meeting',
                content: rawMarkdown
            };
            
            const filename = `è¦ç´„_ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ${segmentId}_${timestamp.replace(/:/g, '-')}.json`;
            const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (err) {
            console.error('Failed to share:', err);
            alert('å…±æœ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }

    /**
     * Export all logs as a single file
     */
    exportAllLogs() {
        try {
            const logEntries = document.querySelectorAll('.log-entry');
            if (logEntries.length === 0) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }

            const allLogs = [];
            const selectedMode = document.querySelector('input[name="recordingMode"]:checked')?.value || 'meeting';
            
            logEntries.forEach(entry => {
                const header = entry.querySelector('.log-header');
                const contentDiv = entry.querySelector('.log-content');
                
                if (!contentDiv || !header || contentDiv.classList.contains('loading')) return;
                
                const segmentMatch = header.textContent.match(/ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ #(\d+)/);
                const timeMatch = header.textContent.match(/(\d{1,2}:\d{2}:\d{2})/);
                
                if (segmentMatch && timeMatch) {
                    const rawMarkdown = contentDiv.dataset.rawMarkdown || contentDiv.textContent;
                    allLogs.push({
                        segmentId: parseInt(segmentMatch[1]),
                        timestamp: timeMatch[1],
                        content: rawMarkdown
                    });
                }
            });

            // Sort by segmentId
            allLogs.sort((a, b) => a.segmentId - b.segmentId);

            const exportData = {
                exportDate: new Date().toISOString(),
                mode: selectedMode,
                totalSegments: allLogs.length,
                logs: allLogs
            };

            const filename = `è¦ç´„ãƒ­ã‚°_å…¨${allLogs.length}ä»¶_${new Date().toISOString().split('T')[0]}.json`;
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (err) {
            console.error('Failed to export:', err);
            alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }
}

// ã‚¢ãƒ—ãƒªæ›´æ–°: ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‰Šé™¤ãƒ»SWè§£é™¤ãƒ»ãƒªãƒ­ãƒ¼ãƒ‰
async function forceAppUpdate() {
    const btn = document.getElementById('btnAppUpdate');
    if (btn) btn.disabled = true;
    try {
        if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (const reg of registrations) await reg.unregister();
        }
        if ('caches' in window) {
            const names = await caches.keys();
            for (const name of names) await caches.delete(name);
        }
        window.location.replace(window.location.pathname + '?t=' + Date.now());
    } catch (err) {
        console.error('Update failed:', err);
        alert('æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚');
        if (btn) btn.disabled = false;
    }
}

// Initialize
let app;
window.addEventListener('DOMContentLoaded', () => {
    app = new RecorderApp();
    
    document.getElementById('btnAppUpdate')?.addEventListener('click', forceAppUpdate);
    
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js')
            .then(registration => {
                console.log('Service Worker registered:', registration);
            })
            .catch(error => {
                console.error('Service Worker registration failed:', error);
            });
    }
});
</script>
</body>
</html>
